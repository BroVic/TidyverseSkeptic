
\documentclass[11pt]{article}
\usepackage{graphicx}

\usepackage{times}
\usepackage{listings}
\usepackage{parcolumns}

\setlength{\parindent}{0in}
\setlength{\parskip}{0.1in}

\title{R Design Patterns: Base-R vs.\ Tidyverse \\
   With an eye toward the teaching of R beginners}
\author{Norman Matloff \\
      Dept. of Computer Science, University of California, Davis}

\begin{document}

\maketitle

This document enables the reader to see at a glance the difference
between base-R and the tidyverse in common R design settings.  I believe
the base-R versions are generally simpler, thus more appropriate for R
learners.

All examples use R's built-in datasets.  After e.g., changing a data
frame, it is restored for the next example, e.g. \textbf{data(mtcars)}.
The examples are presented roughly in order of how often these
operations tend to be performed by R users.

As this document is aimed at comparing base-R and the tidyverse in terms
of teaching new R learners, advanced functions from either base-R or the
tidyverse are excluded here.

More and more examples will be added over time.

\section*{Reading a specific cell in a data frame}

% use by invoking "source ParColsEnv.tex" from Vim


\begin{parcolumns}[rulebetween=true]{2}

\colchunk{

\begin{minipage}{0.40\linewidth}

\begin{lstlisting}

mtcars$mpg[3]

\end{lstlisting}

\end{minipage}

}

\hspace{0.1in}

\colchunk{

\begin{minipage}{0.40\linewidth}

\begin{lstlisting}

select(mtcars,mpg) %>% 
  filter(row_number() == 3)

\end{lstlisting}

\end{minipage}

}

\end{parcolumns}

\section*{Adding a column to a data frame}

\begin{parcolumns}[rulebetween=true]{2}

\colchunk{

\begin{minipage}{0.40\linewidth}

\begin{lstlisting}

mtcars$hwratio 
  <- mtcars$hp / mtcars$wt

\end{lstlisting}

\end{minipage}

}

\hspace{0.1in}

\colchunk{

\begin{minipage}{0.40\linewidth}

\begin{lstlisting}

mutate(mtcars,hwratio=hp/wt) -> mtcars

\end{lstlisting}

\end{minipage}

}

\end{parcolumns}

\bigskip

Of course, typically Tidy coders would use \lstinline{<-}
rather than \lstinline{->}.  I feel that the former is more
consistent with the ``left to right flow'' of pipes.  But in any case,
the point about code complexity is the same either way.

\section*{Extracting rows}

\begin{parcolumns}[rulebetween=true]{2}

\colchunk{

\begin{minipage}{0.40\linewidth}

\begin{lstlisting}

mtc8 <- 
  subset(mtcars,cyl==8)

\end{lstlisting}

\end{minipage}

}

\hspace{0.1in}

\colchunk{

\begin{minipage}{0.40\linewidth}

\begin{lstlisting}

filter(mtcars,mpg > 15) -> mtc8

\end{lstlisting}

\end{minipage}

}

\end{parcolumns}



\section*{Mean by group}

\begin{parcolumns}[rulebetween=true]{2}

\colchunk{

\begin{minipage}{0.40\linewidth}

\begin{lstlisting}

tapply(mtcars$mpg,
  mtcars$cyl,mean)

\end{lstlisting}

\end{minipage}

}

\hspace{0.1in}

\colchunk{

\begin{minipage}{0.40\linewidth}

\begin{lstlisting}

group_by(mtcars, cyl) %>%
  summarize(meanMPG = 
    mean(mpg,))

\end{lstlisting}

\end{minipage}

}

\end{parcolumns}



\section*{Quick look at univariate data}


\begin{parcolumns}[rulebetween=true]{2}

\colchunk{

\begin{minipage}{0.40\linewidth}

\begin{lstlisting}

hist(Nile)

\end{lstlisting}

\end{minipage}

}

\hspace{0.1in}

\colchunk{

\begin{minipage}{0.40\linewidth}

\begin{lstlisting}

dn <- data.frame(Nile)
ggplot(dn) + 
  geom_histogram(aes(Nile),dn)

\end{lstlisting}

\end{minipage}

}

\end{parcolumns}

\bigskip

One could do this more quickly in \textbf{qplot()} than in the full
\textbf{ggplot2}, but this is seldom taught in tidyverse courses.


\section*{Quick look at bivariate data}

\begin{parcolumns}[rulebetween=true]{2}

\colchunk{

\begin{minipage}{0.40\linewidth}

\begin{lstlisting}

plot(x=mtcars$wt,
  y=mtcars$mpg)


\end{lstlisting}

\end{minipage}

}

\hspace{0.1in}

\colchunk{

\begin{minipage}{0.40\linewidth}

\begin{lstlisting}

ggplot(data = mtcars, 
  aes(x = wt, y = mpg)) 
  + geom_point()

\end{lstlisting}

\end{minipage}

}

\end{parcolumns}




\section*{Binary categorization on a vector}

\begin{parcolumns}[rulebetween=true]{2}

\colchunk{

\begin{minipage}{0.40\linewidth}

\begin{lstlisting}
NileHiLow <- 
  ifelse(Nile >= 1000,
    'high','low')
\end{lstlisting}

\end{minipage}

}

\hspace{0.1in}

\colchunk{

\begin{minipage}{0.40\linewidth}

\begin{lstlisting}

Nile %>% as.data.frame %>% 
  mutate(
    HighLow = case_when
    (x < 1000~'low',
     x >= 1000~'high')
  ) %>%
  select(HighLow) %>%
  as.vector -> HighLow


\end{lstlisting}

\end{minipage}

}

\end{parcolumns}

The step of conversion back to a vector at the end is needed for many R
packages in which vector input is required.  

\section*{Deleting columns from a data frame}

\begin{parcolumns}[rulebetween=true]{2}

\colchunk{

\begin{minipage}{0.40\linewidth}

\begin{lstlisting}

mtcars[c('drat','carb')] 
  <- NULL

\end{lstlisting}

\end{minipage}

}

\hspace{0.1in}

\colchunk{

\begin{minipage}{0.40\linewidth}

\begin{lstlisting}

select(mtcars,-c(drat,carb)) 
  -> mtcars

\end{lstlisting}

\end{minipage}

}

\end{parcolumns}


\end{document}

